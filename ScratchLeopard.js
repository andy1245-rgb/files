const t=Symbol("GREEN_FLAG"),e=Symbol("KEY_PRESSED"),s=Symbol("BROADCAST"),i=Symbol("CLICKED"),r=Symbol("CLONE_START");class n{constructor(t,e,s){this.trigger=t,void 0===s?(this.options={},this._script=e):(this.options=e,this._script=s),this.done=!1,this.stop=()=>{}}matches(t,e){if(this.trigger!==t)return!1;for(let t in e)if(this.options[t]!==e[t])return!1;return!0}start(t){this.stop();const e=this._script.bind(t);return this.done=!1,this._runningScript=e(),new Promise(t=>{this.stop=()=>{this.done=!0,t()}})}step(){this.done=this._runningScript.next().done,this.done&&this.stop()}static get GREEN_FLAG(){return t}static get KEY_PRESSED(){return e}static get BROADCAST(){return s}static get CLICKED(){return i}static get CLONE_START(){return r}}class o{static create(){const t=new Float32Array(9);return t[0]=1,t[4]=1,t[8]=1,t}static translate(t,e,s,i){const r=e[0],n=e[1],o=e[2],a=e[3],h=e[4],c=e[5],l=e[6],u=e[7],d=e[8];return t[0]=r,t[1]=n,t[2]=o,t[3]=a,t[4]=h,t[5]=c,t[6]=s*r+i*a+l,t[7]=s*n+i*h+u,t[8]=s*o+i*c+d,t}static rotate(t,e,s){const i=e[0],r=e[1],n=e[2],o=e[3],a=e[4],h=e[5],c=e[6],l=e[7],u=e[8],d=Math.sin(s),f=Math.cos(s);return t[0]=f*i+d*o,t[1]=f*r+d*a,t[2]=f*n+d*h,t[3]=f*o-d*i,t[4]=f*a-d*r,t[5]=f*h-d*n,t[6]=c,t[7]=l,t[8]=u,t}static scale(t,e,s,i){return t[0]=s*e[0],t[1]=s*e[1],t[2]=s*e[2],t[3]=i*e[3],t[4]=i*e[4],t[5]=i*e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}}class a{constructor(t){this.renderer=t,this.gl=t.gl,this.used=!0}getTexture(t){return null}_makeTexture(t,e){const s=this.gl,i=s.createTexture();return s.bindTexture(s.TEXTURE_2D,i),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,e),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,e),t&&s.texImage2D(s.TEXTURE_2D,0,s.RGBA,s.RGBA,s.UNSIGNED_BYTE,t),i}_setSizeFromImage(t){t.complete?(this.width=t.naturalWidth,this.height=t.naturalHeight):t.addEventListener("load",()=>{this.width=t.naturalWidth,this.height=t.naturalHeight})}destroy(){}}const h={vertex:"\nprecision mediump float;\n\nattribute vec2 a_position;\nuniform mat3 u_transform;\nuniform vec2 u_stageSize;\n\nvarying vec2 v_texCoord;\n\nvoid main() {\n  v_texCoord = vec2(a_position.x, 1.0 - a_position.y);\n  gl_Position = vec4((u_transform * vec3(a_position, 1.0)) / vec3(u_stageSize * 0.5, 1.0), 1.0);\n}\n",fragment:"\nprecision mediump float;\n\nconst float epsilon = 1e-3;\n\nuniform sampler2D u_texture;\nvarying vec2 v_texCoord;\n\n#ifdef EFFECT_color\nuniform float u_color;\n#endif\n\n#ifdef EFFECT_fisheye\nuniform float u_fisheye;\n#endif\n\n#ifdef EFFECT_whirl\nuniform float u_whirl;\n#endif\n\n#ifdef EFFECT_pixelate\nuniform float u_pixelate;\nuniform vec2 u_skinSize;\n#endif\n\n#ifdef EFFECT_mosaic\nuniform float u_mosaic;\n#endif\n\n#ifdef EFFECT_brightness\nuniform float u_brightness;\n#endif\n\n#ifdef EFFECT_ghost\nuniform float u_ghost;\n#endif\n\n#if defined(EFFECT_whirl) || defined(EFFECT_fisheye) || defined(EFFECT_pixelate)\nconst vec2 CENTER = vec2(0.5, 0.5);\n#endif\n\n#ifdef DRAW_MODE_COLOR_MASK\nuniform vec4 u_colorMask;\n\n// TODO: Scratch 2.0 and Scratch 3.0's CPU path check if the top 6 bits match,\n// which a tolerance of 3/255 should be equivalent to,\n// but Scratch's GPU path has a tolerance of 2/255.\nconst vec3 COLOR_MASK_TOLERANCE = vec3(3.0 / 255.0);\n#endif\n\n#ifdef EFFECT_color\n// Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n  vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n#endif\n\nvoid main() {\n  vec2 coord = v_texCoord;\n\n  #ifdef EFFECT_mosaic\n  {\n    float mosaicFactor = clamp(floor(abs(u_mosaic + 10.0) / 10.0 + 0.5), 1.0, 512.0);\n    coord = fract(coord * mosaicFactor);\n  }\n  #endif\n\n  #ifdef EFFECT_pixelate\n    vec2 pixSize = u_skinSize / (abs(u_pixelate) * 0.1);\n    coord = (floor(coord * pixSize) + CENTER) / pixSize;\n  #endif\n\n  #ifdef EFFECT_whirl\n  {\n    const float PI_OVER_180 = 0.017453292519943295;\n    vec2 offset = coord - CENTER;\n    float whirlFactor = max(1.0 - (length(offset) * 2.0), 0.0);\n    float whirl = (-u_whirl * PI_OVER_180) * whirlFactor * whirlFactor;\n    float s = sin(whirl);\n    float c = cos(whirl);\n    mat2 rotationMatrix = mat2(c, -s, s, c);\n    coord = rotationMatrix * offset + CENTER;\n  }\n  #endif\n\n  #ifdef EFFECT_fisheye\n  {\n    vec2 vec = (coord - CENTER) / CENTER;\n    float len = length(vec) + epsilon;\n    float factor = max(0.0, (u_fisheye + 100.0) / 100.0);\n    float r = pow(min(len, 1.0), factor) * max(1.0, len);\n    vec2 unit = vec / len;\n    coord = CENTER + (r * unit * CENTER);\n  }\n  #endif\n\n  vec4 color = texture2D(u_texture, coord);\n\n  #if defined(EFFECT_color) || defined(EFFECT_brightness)\n  // Un-premultiply color values by alpha channel\n  vec3 unmul = color.rgb / color.a;\n\n  #ifdef EFFECT_color\n  {\n    vec3 hsv = rgb2hsv(unmul);\n    const float minLightness = 0.11 / 2.0;\n    const float minSaturation = 0.09;\n\n    hsv.z = max(minLightness, hsv.z);\n    hsv.y = max(minSaturation, hsv.y);\n\n    hsv.x = mod(hsv.x + (u_color / 200.0), 1.0);\n\n    unmul = hsv2rgb(hsv);\n  }\n  #endif\n\n  #ifdef EFFECT_brightness\n  {\n    unmul = clamp(unmul + clamp(u_brightness * 0.01, -1.0, 1.0), 0.0, 1.0);\n  }\n  #endif\n\n  color = vec4(unmul * color.a, color.a);\n\n  #endif // defined(defined(EFFECT_color) || defined(EFFECT_brightness))\n\n  #ifdef DRAW_MODE_COLOR_MASK\n  vec3 diff = abs(u_colorMask.rgb - color.rgb);\n  if (any(greaterThan(diff, COLOR_MASK_TOLERANCE))) {\n    discard;\n  }\n  #endif\n\n  #ifdef EFFECT_ghost\n  color *= (1.0 - clamp(u_ghost * 0.01, 0.0, 1.0));\n  #endif\n\n  #ifdef DRAW_MODE_SILHOUETTE\n  if (color.a == 0.0) {\n    discard;\n  }\n  #endif\n\n  gl_FragColor = color;\n}\n"},c={vertex:"\nprecision mediump float;\n\nattribute vec2 a_position;\nuniform vec4 u_penPoints;\nuniform vec2 u_penSkinSize;\nuniform float u_penSize;\n\nvarying vec2 v_texCoord;\n\nvoid main() {\n  float penRadius = u_penSize * 0.5;\n  vec2 topRight = floor(min(u_penPoints.xy, u_penPoints.zw) - penRadius);\n  vec2 bottomLeft = ceil(max(u_penPoints.xy, u_penPoints.zw) + penRadius);\n  vec2 penBounds = a_position * (bottomLeft - topRight) + topRight;\n\n  vec2 position = (penBounds / u_penSkinSize) * 2.0;\n  v_texCoord = penBounds;\n  gl_Position = vec4(position, 1.0, 1.0);\n}\n",fragment:"\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_penPoints;\nuniform vec4 u_penColor;\nuniform float u_penSize;\nvarying vec2 v_texCoord;\n\nvoid main() {\n  // Maaaaagic antialiased-line-with-round-caps shader.\n  // Adapted from Inigo Quilez' 2D distance function cheat sheet\n  // https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n  vec2 pa = v_texCoord - u_penPoints.xy, ba = u_penPoints.zw - u_penPoints.xy;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  float cappedLine = clamp((u_penSize + 1.0) * 0.5 - length(pa - ba*h), 0.0, 1.0);\n\n  // Premultiply pen color by its alpha\n  vec4 premul = vec4(vec3(u_penColor.rgb * u_penColor.a), u_penColor.a);\n\n  gl_FragColor = premul * cappedLine;\n}\n"},l=["color","fisheye","whirl","pixelate","mosaic","brightness","ghost"],u={};for(let t=0;t<l.length;t++)u[l[t]]=1<<t;class d{constructor(t,e){this.gl=t,this.program=e,this._uniformLocations=new Map,this._attribLocations=new Map;const s=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let i=0;i<s;i++){const s=t.getActiveUniform(e,i);this._uniformLocations.set(s.name,t.getUniformLocation(e,s.name))}const i=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES);for(let s=0;s<i;s++){const i=t.getActiveAttrib(e,s);this._attribLocations.set(i.name,t.getAttribLocation(e,i.name))}}attrib(t){return this._attribLocations.get(t)}uniform(t){return this._uniformLocations.get(t)}}class f{constructor(t){this.renderer=t,this.gl=t.gl,this._shaderCache={};for(const t of Object.keys(f.DrawModes))this._shaderCache[t]=new Map}_createShader(t,e){const s=this.gl,i=s.createShader(e);if(s.shaderSource(i,t),s.compileShader(i),!s.getShaderParameter(i,s.COMPILE_STATUS)){throw"Could not compile WebGL program. \n"+s.getShaderInfoLog(i)}return i}getShader(t,e=0){const s=this.gl,i=this._shaderCache[t];if(i.has(e))return i.get(e);{let r;switch(t){case f.DrawModes.DEFAULT:case f.DrawModes.SILHOUETTE:case f.DrawModes.COLOR_MASK:r=h;break;case f.DrawModes.PEN_LINE:r=c}let n=`#define DRAW_MODE_${t}\n`;for(let t=0;t<l.length;t++){const s=l[t];0!=(e&u[s])&&(n+=`#define EFFECT_${s}\n`)}const o=this._createShader(n+r.vertex,s.VERTEX_SHADER),a=this._createShader(n+r.fragment,s.FRAGMENT_SHADER),g=s.createProgram();if(s.attachShader(g,o),s.attachShader(g,a),s.linkProgram(g),!s.getProgramParameter(g,s.LINK_STATUS)){const t=s.getProgramInfoLog(g);throw new Error("Could not compile WebGL program. \n"+t)}const _=new d(s,g);return i.set(e,_),_}}}f.DrawModes={DEFAULT:"DEFAULT",PEN_LINE:"PEN_LINE",SILHOUETTE:"SILHOUETTE",COLOR_MASK:"COLOR_MASK"};class g extends a{constructor(t,e,s){super(t),this.width=e,this.height=s;const i=t._createFramebufferInfo(e,s,this.gl.NEAREST);this._framebufferInfo=i,this._lastPenState={size:0,color:[0,0,0,0]},this.clear()}destroy(){const t=this.gl;t.deleteTexture(this._framebufferInfo.texture),t.deleteFramebuffer(this._framebufferInfo.framebuffer)}getTexture(){return this._framebufferInfo.texture}penLine(t,e,s,i){const r=this.renderer;r._setFramebuffer(this._framebufferInfo);const n=r._shaderManager.getShader(f.DrawModes.PEN_LINE),o=this.gl,a=r._setShader(n);a&&o.uniform2f(n.uniform("u_penSkinSize"),this.width,this.height);const h=s.toRGBANormalized(),c=this._lastPenState.color;(a||h[0]!==c[0]||h[1]!==c[1]||h[2]!==c[2]||h[3]!==c[3])&&(this._lastPenState.color=h,o.uniform4fv(n.uniform("u_penColor"),h)),(a||this._lastPenState.size!==i)&&(this._lastPenState.size=i,o.uniform1f(n.uniform("u_penSize"),i)),o.uniform4f(n.uniform("u_penPoints"),t.x,t.y,e.x,e.y),o.drawArrays(o.TRIANGLES,0,6)}clear(){this.renderer._setFramebuffer(this._framebufferInfo);const t=this.gl;t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT)}}class _{constructor(){return this.left=-1/0,this.right=1/0,this.bottom=-1/0,this.top=1/0,this}static fromBounds(t,e,s,i,r){return r||(r=new _),r.left=t,r.right=e,r.bottom=s,r.top=i,r}static fromMatrix(t,e){e||(e=new _);const s=t[0]/2,i=t[3]/2,r=Math.abs(s)+Math.abs(i),n=s+i+t[6],o=t[1]/2,a=t[4]/2,h=Math.abs(o)+Math.abs(a),c=o+a+t[7];return e.left=n-r,e.right=n+r,e.bottom=c-h,e.top=c+h,e}snapToInt(){return this.left=Math.floor(this.left),this.right=Math.ceil(this.right),this.bottom=Math.floor(this.bottom),this.top=Math.ceil(this.top),this}intersects(t){return this.left<=t.right&&t.left<=this.right&&this.top>=t.bottom&&t.top>=this.bottom}containsPoint(t,e){return t>=this.left&&t<=this.right&&e>=this.bottom&&e<=this.top}clamp(t,e,s,i){return this.left=Math.min(Math.max(this.left,t),e),this.right=Math.max(Math.min(this.right,e),t),this.bottom=Math.min(Math.max(this.bottom,s),i),this.top=Math.max(Math.min(this.top,i),s),this}static union(t,e,s=new _){return s.left=Math.min(t.left,e.left),s.right=Math.max(t.right,e.right),s.bottom=Math.min(t.bottom,e.bottom),s.top=Math.max(t.top,e.top),s}static intersection(t,e,s=new _){return s.left=Math.max(t.left,e.left),s.right=Math.min(t.right,e.right),s.bottom=Math.max(t.bottom,e.bottom),s.top=Math.min(t.top,e.top),s}get width(){return this.right-this.left}get height(){return this.top-this.bottom}}class m extends a{constructor(t,e){super(t),this._image=e,this._texture=null,this._setSizeFromImage(e)}getTexture(){const t=this._image;return t.complete?(null===this._texture&&(this._texture=super._makeTexture(t,this.gl.NEAREST)),this._texture):null}destroy(){null!==this._texture&&this.gl.deleteTexture(this._texture)}}const p=170,E=4,b=12,T=12;class y extends a{constructor(t,e){super(t),this._canvas=document.createElement("canvas"),this._texture=this._makeTexture(null,this.gl.LINEAR),this._bubble=e,this._flipped=!1,this._rendered=!1,this._renderedScale=0,this.width=0,this.height=0,this.offsetX=-E/2,this.offsetY=this.offsetX+T,this._renderBubble(this._bubble)}_restyleCanvas(){const t=this._canvas.getContext("2d");t.font="16px sans-serif",t.textBaseline="hanging"}set flipped(t){this._flipped=t,this._rendered=!1}_renderBubble(t,e){const s=this._canvas,i=s.getContext("2d");this._restyleCanvas();const{text:r,style:n}=t,o=i.measureText(r).width,a=p,h=b,c=Math.ceil(Math.min(o,a)+2*h),l=10+2*h;this.width=c+E,this.height=l+T+E,s.width=this.width*e,s.height=this.height*e,this._restyleCanvas();const u=E/2,d=u;i.setTransform(e,0,0,e,0,0),i.fillStyle="#fff",i.strokeStyle="#ccc",i.lineWidth=E,i.save(),this._flipped&&(i.scale(-1,1),i.translate(-this.width,0)),((t,e,s,r,n,o)=>{n>s/2&&(n=s/2),n>r/2&&(n=r/2),n<0||(i.beginPath(),i.moveTo(t+n,e),i.arcTo(t+s,e,t+s,e+r,n),i.arcTo(t+s,e+r,t+n,e+r,n),"say"===o?(i.lineTo(Math.min(t+3*n,t+s-n),e+r),i.lineTo(t+n/2,e+r+n),i.lineTo(t+n,e+r)):"think"===o&&i.ellipse(t+2.25*n,e+r,3*n/4,n/2,0,0,Math.PI),i.arcTo(t,e+r,t,e,n),i.arcTo(t,e,t+s,e,n),i.closePath(),i.stroke(),i.fill(),"think"===o&&(i.beginPath(),i.ellipse(t+n,e+r+3*n/4,n/3,n/3,0,0,2*Math.PI),i.stroke(),i.fill()))})(u,d,c,l,T,n),i.restore(),i.fillStyle="#444",i.fillText(r,u+h,d+h,a),this._rendered=!0,this._renderedScale=e}getTexture(t){if(!this._rendered||this._renderedScale!==t){this._renderBubble(this._bubble,t);const e=this.gl;e.bindTexture(e.TEXTURE_2D,this._texture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,this._canvas)}return this._texture}destroy(){this.gl.deleteTexture(this._texture)}}class x extends a{constructor(t,e){super(t),this._image=e,this._canvas=document.createElement("canvas"),this._maxTextureSize=t.gl.getParameter(t.gl.MAX_TEXTURE_SIZE),this._setSizeFromImage(e),this._mipmaps=new Map}_createMipmap(t){const e=2**(t-4),s=this._canvas,i=s.getContext("2d"),r=this._image;let n=r.naturalWidth*e,o=r.naturalHeight*e;n=Math.round(Math.min(n,this._maxTextureSize)),o=Math.round(Math.min(o,this._maxTextureSize)),0!==n&&0!==o?(s.width=n,s.height=o,i.drawImage(r,0,0,n,o),this._mipmaps.set(t,this._makeTexture(s,this.gl.LINEAR))):this._mipmaps.set(t,null)}getTexture(t){if(!this._image.complete)return null;const e=Math.max(Math.ceil(Math.log2(t))+4,0);return this._mipmaps.has(e)||this._createMipmap(e),this._mipmaps.get(e)}destroy(){for(const t of this._mipmaps.values())this.gl.deleteTexture(t)}}class S{constructor(t,e,s={x:0,y:0}){this.name=t,this.url=e,this.img=new Image,this.img.crossOrigin="Anonymous",this.img.src=this.url,this.isBitmap=!this.url.match(/\.svg/),this.resolution=this.isBitmap?2:1,this.center=s}get width(){return this.img.naturalWidth}get height(){return this.img.naturalHeight}}class w{constructor(t){this._renderer=t,this.gl=t.gl,this._skins=new Map}beginTrace(){this._skins.forEach(t=>{t.used=!1})}endTrace(){this._skins.forEach((t,e)=>{t.used||(t.destroy(),this._skins.delete(e))})}getSkin(t){if(this._skins.has(t)){const e=this._skins.get(t);return e.used=!0,e}{let e;return e=t instanceof S?t.isBitmap?new m(this._renderer,t.img):new x(this._renderer,t.img):new y(this._renderer,t),this._skins.set(t,e),e}}}const v=(t,e,s)=>Math.max(e,Math.min(s,t));function C(t,e,s){t/=255,e/=255,s/=255;const i=Math.max(t,e,s),r=i-Math.min(t,e,s);let n=0;0===r||(i===t?n=((e-s)/r+6)%6/6:i===e?n=((s-t)/r+2)%6/6:i===s&&(n=((t-e)/r+4)%6/6));let o=0;return 0!==i&&(o=r/i),{h:100*n,s:100*o,v:100*i}}function R(t,e,s){t=t/100*360;const i=(s/=100)*(e/=100),r=i*(1-Math.abs(t/60%2-1)),n=s-i;let o=n,a=n,h=n;return t<60?(o+=i,a+=r):t<120?(a+=i,o+=r):t<180?(a+=i,h+=r):t<240?(h+=i,a+=r):t<300?(h+=i,o+=r):t<360&&(o+=i,h+=r),{r:255*o,g:255*a,b:255*h}}class A{constructor(t=0,e=0,s=0,i=1){this.h=t,this.s=e,this.v=s,this.a=i}static rgb(t,e,s,i=1){const{h:r,s:n,v:o}=C(t,e,s);return new A(r,n,o,i)}static hsv(t,e,s,i=1){return new A(t,e,s,i)}static num(t){const e=(t=Number(t))>>24&255,s=t>>16&255,i=t>>8&255,r=255&t;return A.rgb(s,i,r,e>0?e/255:1)}get r(){return R(this.h,this.s,this.v).r}set r(t){this._setRGB(t,this.g,this.b)}get g(){return R(this.h,this.s,this.v).g}set g(t){this._setRGB(this.r,t,this.b)}get b(){return R(this.h,this.s,this.v).b}set b(t){this._setRGB(this.r,this.g,t)}get a(){return this._a}set a(t){this._a=v(t,0,1)}get h(){return this._h}set h(t){this._h=(t%100+100)%100}get s(){return this._s}set s(t){this._s=v(t,0,100)}get v(){return this._v}set v(t){this._v=v(t,0,100)}_setRGB(t,e,s){t=v(t,0,255),e=v(e,0,255),s=v(s,0,255);const{h:i,s:r,v:n}=C(t,e,s);this.h=i,this.s=r,this.v=n}toHexString(t=!1){const e=t=>{let e=(t=v(Math.round(t),0,255)).toString(16);return 1===e.length&&(e="0"+e),e};let s="#"+[this.r,this.g,this.b].map(e).join("");return(t||1!==this.a)&&(s+=e(255*this.a)),s}toRGBString(t=!1){const e=[this.r,this.g,this.b].map(Math.round);return t||1!==this.a?`rgba(${e.join(", ")}, ${this.a})`:`rgb(${e.join(", ")})`}toRGBA(){const t=R(this._h,this._s,this._v);return[t.r,t.g,t.b,255*this._a]}toRGBANormalized(){const t=R(this._h,this._s,this._v);return[t.r/255,t.g/255,t.b/255,this._a]}toString(){return this.toRGBString()}}
